# JavaDesignPattern
java design pattern:java设计模式示例代码
设计模式是一套被反复使用、多数人知晓的、经过分类编目、代码设计经验的总结，其核心思想就是“分工” 。
使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。
创建模式
	 Singleton(单例) 、Factory(工厂方法和抽象工厂)、Builder(建造者)、Prototype(原型)
结构模式
	Adapter(适配器)、Proxy(代理)、Facade（外观）、Composite(组合)、Decorator(装饰)、Bridge(桥接)、Flyweight(共享元) 
行为模式
	Command(命令)、Observer(观察者)、Template(模板)、Strategy(策略)、Chain of Responsibility(职责链)、Mediator(中介者)、State(状态)、Memento(备忘录)、Interpreter(解释器)、Visitor(访问者)、(Iterator)迭代子模式

面对对象编程七大原则
1.OCP  全称：“Open-Closed Principle” 开放－封闭原则  说明：对扩展开放，对修改关闭。 
2.LSP  全称：“Liskov Substitution Principle” 里氏代换原则  说明：子类型必须能够替换它们的基类型。一个软件实体如果使用的是一个基类，那么当把这个基类替换成继承该基类的子类，程序的行为不会发生任何变化。软件实体察觉不出基类对象和子类对象的区别。
3.DIP  全称：“Dependence Inversion Principle”依赖倒置原则  说明：要依赖于抽象，不要依赖于具体。客户端依赖于抽象耦合。 
4.ISP  全称：“Interface Segregation Principle” 接口隔离原则  说明：使用多个专一功能的接口比使用一个的总接口总要好。
5.CARP or CRP  全称：“Composite/Aggregate Reuse Principle” 合成/聚合复用原则 or “Composite Reuse Principle” 合成复用原则  说明：如果新对象的某些功能在别的已经创建好的对象里面已经实现，那么尽量使用别的对象提供的功能，使之成为新对象的一部分，而不要自己再重新创建。新对象通过向这些对象的委派达到复用已有功能的。  简而言之，要尽量使用合成/聚合，尽量不要使用继承。
6.LOD or LKP  全称：“Law of Demeter” 迪米特原则 or “Least Knowledge Principle” 最少知识原则  说明：对象与对象之间应该使用尽可能少的方法来关联，避免千丝万缕的关系。 
7.单一职责原则：   SRP简介（SRP--Single-Responsibility Principle）：就一个类而言，应该只专注于做一件事和仅有一个引起它变化的原因。

单例模式（创建模式）
Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在

列如：
读取配置文件的类，一般只有一个对象。
应用程序中的日志应用，一般也用单例实现，一般由于共享的日志文件一直打开状态，只能有一个实例操作，否则内容不好追加。

优点：
由于只有一个实例，减少系统性能开销；
优化系统资源共享访问

5种实现方式：
主要：
饿汉式（线程安全，调用效率高，但不能延时加载）
懒汉式（线程安全，调用效率不高，但可以延时加载）
其它：
双重检测锁（由于JVM底层原因，偶尔出问题，不建议使用）
静态内部式（线程安全，调用效率高 ，可以延时加载）
枚举单例（线程安全，调用效率高，但不可以延时加载）

如何选用：
单例对象占用资源少，不需要延时加载：
枚举式    好于   饿汉式

单例对象占用资源大，需要延时加载：
静态内部式     好于  懒汉式


Factory模式（创建模式）
核心本质
实例化对象，用工厂方法替代new操作
将选择实现类、创建对象统一管理和控制，从而将调用者同实现类解耦

简单工厂
用来生成同一等级的任意产品
工厂方法
用来生成同一等级结构中的固定产品
抽象工厂
用来生成不同产品族的全部产品。

工厂模式的优点：  
1、其可以为用户创建一系列相关的对象，使用户和创建这些类的对象脱耦  
2、可以方便用户创建一系列对象，用户使用不同的具体工厂就能得到一组相关的对象，同时也能避免用户混用不同系列中的对象  
3、可以随时增加“具体工厂”为用户提供一组相关的对象

Builder模式(建造者) （创建模式）
将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示。
 Builder模式是一步一步创建一个复杂的对象,它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们.用户不知道内部的具体构建细节。

如何使用? 
是为了将构建复杂对象的过程和它的部件解耦.
注意: 是解耦过程和部件. 因为一个复杂的对象,不但有很多大量组成部分,如汽车,有很多部件:车轮 方向盘 发动机还有各种小零件等等,部件很多,但远不止这些,如何将这些部件装配成一辆汽车,这个装配过程也很复杂(需要很好的组装技术),Builder模式就是为了将部件和组装过程分开.


Prototype模式(原型) （创建模式）
通过拷贝原型实例创建新的对象。

Java中的提供clone()方法来实现对象的克隆。
缺点：每一个类必须配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事。

Object  toJson String  json String  toObject Class

Adapter模式(适配器)（结构模式）
将一个类的接口转换为客户希望的另一个接口。Adapter使原本接口不兼容 不能一起工作的类    使之可以在一起工作。

Proxy模式(代理) （结构模式）
为客户对象提供一种代理，以控制客户对真实角色对象的访问
代理概念可以解释为:在出发点到目的地之间有一道中间层,意为代理

1.静态代理
存在问题：需要建立大量的代理类，重复代码

2.动态代理
其实现通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口。 
Proxy类主要用来获取动态代理对象，InvocationHandler接口用来约束调用者实现。
其实现只支持对接口的代理实现。

Facade模式（外观） （结构模式）
为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用。
外观模式将子系统的一组接口集成在一起的高层接口，以提供一个一致的界面。通过这个界面，其他系统可以方便的调用子系统中的功能，而忽略子系统内部发生的变化。
上图可以看出,外观模式实际上是个理顺系统间关系,降低系统间耦合度的一个常用的办法


Composite模式(组合) （结构模式）
将对象以树形结构组织起来,以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性.

1.不必关系自己处理的是单个对象还是整个组合结构

2.不必加入了新的对象部件而更改代码


Decorator模式(装饰) （结构模式）
装饰模式是动态的扩展一个对象的功能，而不是改变原始类代码

适用性

1.在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。

2.处理那些可以撤消的职责。

3.当不能采用生成子类的方法进行扩充时。


Bridge模式(桥接) （结构模式）
将抽象和行为划分开来,各自独立,但能动态的结合。
在面向对象设计的基本概念中，对象这个概念实际是由属性和行为两个部分组成的，属性我们可以认为是一种静止的，是一种抽象，一般情况下，行为是包含在一个对象中，但是，在有的情况下，我们需要将这些行为也进行归类，形成一个总的行为接口，这就是桥模式的用处。

为什么使用? 
不希望抽象部分和行为有一种固定的绑定关系，而是应该可以动态联系的。
多层继承结构的时候可以使用该模式


Flyweight模式(共享元) （结构模式）
避免大量拥有相同内容的小类的开销(如耗费内存),使大家共享一个类(元类) 。

先捏一个的原始模型,然后随着不同场合和环境,再产生各具特征的具体模型,很显然,在这里需要产生不同的新对象,所以Flyweight模式中常出现Factory模式.Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象. 

Flyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多:比如你要从一个数据库中读取一系列字符串,这些字符串中有许多是重复的,那么我们可以将这些字符串储存在Flyweight池(pool)中.


Command(命令)（行为模式）
将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。 
优点: 
解耦了调用者和接受者之间联系。调用者调用一个操作，接受者接受请求执行相应的动作，因为使用Command模式解耦，调用者无需知道接受者任何接口。 
缺点: 
造成出现过多的具体命令类


Observer(观察者) （行为模式）
比较常用的一个模式,尤其在界面设计中应用广泛

当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！
1.Subject（目标)
目标知道它的观察者。可以有任意多个观察者观察同一个目标。       
提供注册和删除观察者对象的接口。       

2.Observer（观察者）
为那些在目标发生改变时需获得通知的对象定义一个更新接口。



Template(模板) （行为模式）
定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中
1.一次性实现一个算法的不变的部分，并将可变的部分留给子类来实现。
     
2.各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。

首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。
最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。


Strategy(策略) （行为模式）
策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。
这个模式涉及到三个角色：
●　　环境(Context)角色：持有一个Strategy的引用。
●　　抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
●　　具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。


Chain of Responsibility(职责链) （行为模式）
用一系列类(classes)试图处理一个请求request,这些类之间是一个松散的耦合,唯一共同点是在他们之间传递request. 也就是说，来了一个请求，A类先处理，如果没有处理，就传递到B类处理，如果没有处理，就传递到C类处理，就这样象一个链条(chain)一样传递下去。
CoR的优点： 
因为无法预知来自外界（客户端）的请求是属于哪种类型，每个类如果碰到它不能处理的请求只要放弃就可以。
缺点是:
效率低，因为一个请求的完成可能要遍历到最后才可能完成，当然也可以用树的概念优化。 因为在CoR中，一定要有一个统一的接口Handler.局限性就在这里。 

与Command模式区别： 
Command 模式需要事先协商客户端和服务器端的调用关系，比如 1 代表 start 2 代表 move 等，这些 都是封装在 request 中，到达服务器端再分解。 

CoR 模式就无需这种事先约定，服务器端可以使用 CoR 模式进行客户端请求的猜测，一个个猜测 试验。

Mediator(中介者) （行为模式）
定义:
用 一个中介对象    封装  一系列对象交互行为。

为何使用Mediator? 
各个对象之间的交互操作非常多;每个对象的行为操作都依赖彼此对方,修改一个对象的行为,同时会涉及到修改很多其他对象的行为,如果使用Mediator模式,可以使各个对象间的耦合松散,只需关心和 Mediator的关系,使多对多的关系变成了一对多的关系,可以降低系统的复杂性,提高可修改扩展性。

State(状态) （行为模式）
定义: 
不同的状态,不同的行为;或者说,每个状态有着相应的行为
何时使用? 
State模式在实际使用中比较多,适合"状态的切换".因为我们经常会使用If else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式

是否使用? 
在实际使用,类似开关一样的状态切换是很多的,但有时并不是那么明显,取决于你的经验和对系统的理解深度. 
这里要阐述的是"开关切换状态" 和" 一般的状态判断"是有一些区别的, " 一般的状态判断"也是有 if..elseif结构,例如: 
if (which==1) state="hello"; 
else if (which==2) state="hi"; 
else if (which==3) state="bye"; 
这是一个 " 一般的状态判断",state值的不同是根据which变量来决定的,which和state没有关系.
如果改成: 
if (state.euqals("bye")) state="hello"; 
else if (state.euqals("hello")) state="hi"; 
else if (state.euqals("hi")) state="bye"; 

这就是 "开关切换状态",是将state的状态从"hello"切换到"hi",再切换到""bye";在切换到"hello",好象一个旋转开关,这种状态改变就可以使用State模式了. 
如果单纯有上面一种将"hello"-->"hi"-->"bye"-->"hello"这一个方向切换,也不一定需要使用State模式,因为State模式会建立很多子类,复杂化,
但是如果又发生另外一个行为:将上面的切换方向反过来切换,或者需要任意切换,就需要State了.


Memento(备忘录) （行为模式）
备忘录模式又叫做快照模式(Snapshot Pattern)。它是在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。
组成部分：

发起人(Originator): 负责创建一个备忘录Memento,用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。发起人可以根据需要觉得备忘录存储自己的哪些内部状态。

备忘录(Memento): 负责存储发起人对象的内部状态，并可以防止发起人以外的其他对象访问备忘录。备忘录有两个接口：管理者只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。发起人却可以看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。

管理者(Caretaker): 负责备忘录，不能对备忘录的内容进行访问或者操作。


Interpreter(解释器) （行为模式）
解释器模式定义语言的文法，并且建立一个解释器来解释该语言中的句子
应用环境：
如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。
优点：
解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。

缺点：
解释器模式会引起类膨胀，每个语法都要产生一个非终结符表达式，语法规则比较复杂时，可能产生大量的类文件，难以维护。
解释器模式采用递归调用方法，它导致调试非常复杂。
解释器由于使用了大量的循环和递归，所以当用于解析复杂、冗长的语法时，效率是难以忍受的

注意事项：
尽量不要在重要模块中使用解释器模式，因为维护困难。


Visitor(访问者) （行为模式）
一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。

访问者模式的目的是要把  处理  从数据结构中分离出来，如果系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式是个不错的选择，因为访问者模式使的算法操作的增加变得容易。

相反，如果系统的数据结构不稳定，易于变化，则此系统就不适合使用访问者模式了。



(Iterator)迭代子模式（行为模式） 
迭代器模式又叫做游标（Cursor)模式。
提供一种方法顺序访问一个聚集对象中的各个元素，而又不暴露该对象的内部细节。
这句话包含两层意思：
一是需要遍历的对象，即聚集对象，
二是迭代器对象，用于对聚集对象进行遍历访问。

